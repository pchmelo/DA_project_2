Problema: Tentar desenvolver um algoritmo que seja capaz de entregar uma solução para um grafo, que não seja
possível fazer um circuito (passar por todos os vértices do grafo sem repetir um vértice).

Contexto: Em situações da vida real, não existe sempre um caminho que passe por todos os cidades (vértices), por exemplo
uma cidade que esteja localizada numa montanha, muito provavelmente terá que voltar à cidade anterior. Ou seja, não
é possível fazer um circuito. Desta forma, o algoritmo desenvolvido terá de ser capaz de entregar uma solução que
passe em todas cidades, mas sem a restrição de não repetir cidades.

Problema: Ao remover as restrições para o problema, faz com que aumente as possibilidades de soluções, tornando o problema
mais complexo. Entregar uma possivel solução para o problema até pode ser simples, mas a melhor ou até mesmo uma boa solução
pode ser muito mais difícil de encontrar.


Considerações: Como não é possível ter a certeza de qual seria o melhor resultado para o problema (já que teria uma
maior complexidade que o problema original), terá que se recorrer na mesma a um valor de referência para avaliar o
resultado obtido. Poderá ser assim utilizado o valor da Weight do grafo 1-Tree como lower bound para avaliar a solução.

Para resolver este problema será possível utilizar dois diferentes algoritmos.

1.ª Solução - DFS (Depth First Search):
Nesta solução, será utilizado o algoritmo DFS como base para encotrar um possível caminho. O algoritmo irá percorrer
o grafo, visitando todos os vértices, mas sem a restrição de não repetir vértices. Caso ele depare com algum vértice que
já tenha sido visitado, ele irá ignorar e continuar a sua busca. Caso não exista mais vértices para visitar, ele irá
fazer backtracking até encontrar um vértice que ainda não tenha sido visitado. O algoritmo irá terminar quando todos os
vertices tiverem sido visitados pelo menos uma vez. No final ele irá voltar à origem. Todos os vertices por onde o algoritmo
passa são guardados numa lista, que será a solução do problema.

Passos:
1. Inicializar o grafo com todos os vértices como unvisited;
2. Inicializar uma lista para guardar os vértices visitados (caminho formado);
3. Encontrar o vértice de origem;
4. Realizar o algoritmo DFS, visitando todos os vértices (guardar todos os vértices atravessados);
5. Retornar à origem (poderá ter que fazer backtracking até poder voltar à origem);
6. Calcular o valor do caminho encontrado.

Comentários sobre a primeira solução:
Este algoritmo é simples, rápido e garante uma solução para o problema. No entanto,
não garante que seja a melhor solução. O algoritmo irá percorrer todos os vértices, mas não garante que o caminho seja
o mais curto, nem uma solução ótima. No entanto, é uma solução que pode ser utilizada para avaliar a qualidade de outras
soluções. Caso o grafo seja muito grande, o algoritmo poderá ser uma boa opção para encontrar uma solução rápida.

2.ª Solução - Greedy Algorithm modificado
Nesta solução, será utilizado um algoritmo greedy já previamente utilizado para resolver o 4.2. Para uma situação de um grafo que
seja conectado (regular TSP)

