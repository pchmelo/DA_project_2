<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA 2nd Project: grafos Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA 2nd Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgrafos-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">grafos Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac3b0761f909a8cbdff939f6d0de17df" id="r_aac3b0761f909a8cbdff939f6d0de17df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3b0761f909a8cbdff939f6d0de17df">resetStatus</a> ()</td></tr>
<tr class="memdesc:aac3b0761f909a8cbdff939f6d0de17df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reset the status of the graph.  <br /></td></tr>
<tr class="separator:aac3b0761f909a8cbdff939f6d0de17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54873ab1bfc738303fa75a8b820e3e32" id="r_a54873ab1bfc738303fa75a8b820e3e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54873ab1bfc738303fa75a8b820e3e32">checkEdge</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, <a class="el" href="class_edge.html">int</a> dest, <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; <a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:a54873ab1bfc738303fa75a8b820e3e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if an edge exists between two vertices.  <br /></td></tr>
<tr class="separator:a54873ab1bfc738303fa75a8b820e3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d3ec5988d33c1598742557c7b9600" id="r_a254d3ec5988d33c1598742557c7b9600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254d3ec5988d33c1598742557c7b9600">copyGraph</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; <a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:a254d3ec5988d33c1598742557c7b9600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to copy a graph.  <br /></td></tr>
<tr class="separator:a254d3ec5988d33c1598742557c7b9600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738324b6b76cfc54997a4f7b87d49c3" id="r_ab738324b6b76cfc54997a4f7b87d49c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab738324b6b76cfc54997a4f7b87d49c3">addAllEdge</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">choice</a>, std::string type)</td></tr>
<tr class="memdesc:ab738324b6b76cfc54997a4f7b87d49c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add all edges to the graph.  <br /></td></tr>
<tr class="separator:ab738324b6b76cfc54997a4f7b87d49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bbb41ce774505a8a69d46ae95f7df5" id="r_a97bbb41ce774505a8a69d46ae95f7df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97bbb41ce774505a8a69d46ae95f7df5">readCoordinates</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">choice</a>, std::string type)</td></tr>
<tr class="memdesc:a97bbb41ce774505a8a69d46ae95f7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read the coordinates of a vertex.  <br /></td></tr>
<tr class="separator:a97bbb41ce774505a8a69d46ae95f7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839bcdcc61158c81bd19fcabc3d8867" id="r_a6839bcdcc61158c81bd19fcabc3d8867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6839bcdcc61158c81bd19fcabc3d8867">readGraph</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">choice</a>, std::string type)</td></tr>
<tr class="memdesc:a6839bcdcc61158c81bd19fcabc3d8867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read the graph.  <br /></td></tr>
<tr class="separator:a6839bcdcc61158c81bd19fcabc3d8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbba3bc3edbc813f3959cf473791859" id="r_aecbba3bc3edbc813f3959cf473791859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbba3bc3edbc813f3959cf473791859">checkGraph</a> (std::string type)</td></tr>
<tr class="memdesc:aecbba3bc3edbc813f3959cf473791859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check the graph.  <br /></td></tr>
<tr class="separator:aecbba3bc3edbc813f3959cf473791859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00171c8a1453c1ee4bbb7a5c7444bba" id="r_ae00171c8a1453c1ee4bbb7a5c7444bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00171c8a1453c1ee4bbb7a5c7444bba">normalizationRealCoordinates</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>)</td></tr>
<tr class="memdesc:ae00171c8a1453c1ee4bbb7a5c7444bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to normalize the real coordinates of the graph.  <br /></td></tr>
<tr class="separator:ae00171c8a1453c1ee4bbb7a5c7444bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e56ee09b55cfa54f9d781ab6eb6fbf" id="r_ad1e56ee09b55cfa54f9d781ab6eb6fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e56ee09b55cfa54f9d781ab6eb6fbf">normalizeGraph</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>)</td></tr>
<tr class="memdesc:ad1e56ee09b55cfa54f9d781ab6eb6fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to normalize the graph.  <br /></td></tr>
<tr class="separator:ad1e56ee09b55cfa54f9d781ab6eb6fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a6993836d0ebb80076ed840c55ada" id="r_a838a6993836d0ebb80076ed840c55ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838a6993836d0ebb80076ed840c55ada">triangular_approximation</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v1</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v2</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v3</a>)</td></tr>
<tr class="memdesc:a838a6993836d0ebb80076ed840c55ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that makes the triangular approximation of the graph.  <br /></td></tr>
<tr class="separator:a838a6993836d0ebb80076ed840c55ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e661e5c0a2290e12c2abac63c8dd16" id="r_a41e661e5c0a2290e12c2abac63c8dd16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41e661e5c0a2290e12c2abac63c8dd16">convertToRadians</a> (<a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">degree</a>)</td></tr>
<tr class="memdesc:a41e661e5c0a2290e12c2abac63c8dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert from degrees to radians.  <br /></td></tr>
<tr class="separator:a41e661e5c0a2290e12c2abac63c8dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ea96623f69e3519731989f2568e5f" id="r_a842ea96623f69e3519731989f2568e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842ea96623f69e3519731989f2568e5f">calculateDistanceHaverside</a> (<a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">long1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat2</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">long2</a>)</td></tr>
<tr class="memdesc:a842ea96623f69e3519731989f2568e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the distance between two points using the Haverside formula.  <br /></td></tr>
<tr class="separator:a842ea96623f69e3519731989f2568e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6590210b146b0659f6779c6db071d74" id="r_ad6590210b146b0659f6779c6db071d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6590210b146b0659f6779c6db071d74">maxWeightOneTree</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">primCost</a>)</td></tr>
<tr class="memdesc:ad6590210b146b0659f6779c6db071d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the maximum weight of a tree.  <br /></td></tr>
<tr class="separator:ad6590210b146b0659f6779c6db071d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e14b39e16bce4ccce94e88a2b17e6" id="r_a6b6e14b39e16bce4ccce94e88a2b17e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b6e14b39e16bce4ccce94e88a2b17e6">prim</a> ()</td></tr>
<tr class="memdesc:a6b6e14b39e16bce4ccce94e88a2b17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the prim's algorithm.  <br /></td></tr>
<tr class="separator:a6b6e14b39e16bce4ccce94e88a2b17e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44f7d8b936ce9f90f582f23fe8feeb2" id="r_aa44f7d8b936ce9f90f582f23fe8feeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44f7d8b936ce9f90f582f23fe8feeb2">convertPrimToGraph</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; <a class="el" href="class_edge.html">mst</a>)</td></tr>
<tr class="memdesc:aa44f7d8b936ce9f90f582f23fe8feeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert the minimum spanning tree into a graph.  <br /></td></tr>
<tr class="separator:aa44f7d8b936ce9f90f582f23fe8feeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10cde47adf8493b4cada671f10397b9" id="r_af10cde47adf8493b4cada671f10397b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af10cde47adf8493b4cada671f10397b9">primTotalCost</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;path)</td></tr>
<tr class="memdesc:af10cde47adf8493b4cada671f10397b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the total cost of the minimum spanning tree.  <br /></td></tr>
<tr class="separator:af10cde47adf8493b4cada671f10397b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1626d9c196b32de2fd96bde5addedaf" id="r_af1626d9c196b32de2fd96bde5addedaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1626d9c196b32de2fd96bde5addedaf">lowerBoundCommander</a> (<a class="el" href="class_edge.html">bool</a> <a class="el" href="class_edge.html">flag</a>, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:af1626d9c196b32de2fd96bde5addedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the value of the lower bound.  <br /></td></tr>
<tr class="separator:af1626d9c196b32de2fd96bde5addedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e1d3587c5193995fdb9f782c8e5b1b" id="r_ac4e1d3587c5193995fdb9f782c8e5b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e1d3587c5193995fdb9f782c8e5b1b">backtrackingAlgorithm</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">source</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:ac4e1d3587c5193995fdb9f782c8e5b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that explores all possible paths from the source vertex to all other vertices in the graph.  <br /></td></tr>
<tr class="separator:ac4e1d3587c5193995fdb9f782c8e5b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b68ee88c4d1f30f96f41688dd77594" id="r_ae5b68ee88c4d1f30f96f41688dd77594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b68ee88c4d1f30f96f41688dd77594">auxBacktrackingAlgorithm</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v_src</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">vertex</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">current_path</a>, <a class="el" href="class_edge.html">double</a> &amp;res, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">cost_now</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">count</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path)</td></tr>
<tr class="memdesc:ae5b68ee88c4d1f30f96f41688dd77594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that explores all possible paths from the source vertex to all other vertices in the graph.  <br /></td></tr>
<tr class="separator:ae5b68ee88c4d1f30f96f41688dd77594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8cee0b704f0caa51afbea8d85c2562" id="r_a6d8cee0b704f0caa51afbea8d85c2562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8cee0b704f0caa51afbea8d85c2562">checkEdge</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">vertex</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *dest, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&amp;<a class="el" href="class_edge.html">edge</a>)</td></tr>
<tr class="memdesc:a6d8cee0b704f0caa51afbea8d85c2562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if an edge exists between two vertices.  <br /></td></tr>
<tr class="separator:a6d8cee0b704f0caa51afbea8d85c2562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2005eb1d02071cdb216fdf0b55721d" id="r_a4a2005eb1d02071cdb216fdf0b55721d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a2005eb1d02071cdb216fdf0b55721d">triangularApproximationHeuristic</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:a4a2005eb1d02071cdb216fdf0b55721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the triangular approximation heuristic.  <br /></td></tr>
<tr class="separator:a4a2005eb1d02071cdb216fdf0b55721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ffefbe60aabccb9bb4ca1665f7159a" id="r_a70ffefbe60aabccb9bb4ca1665f7159a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70ffefbe60aabccb9bb4ca1665f7159a">commanderTriangularApprox</a> ()</td></tr>
<tr class="memdesc:a70ffefbe60aabccb9bb4ca1665f7159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that applies the triangular approximation to all vertices in the graph.  <br /></td></tr>
<tr class="separator:a70ffefbe60aabccb9bb4ca1665f7159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4f949174e97ccabdf916a2d1f8a4bb" id="r_a0c4f949174e97ccabdf916a2d1f8a4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4f949174e97ccabdf916a2d1f8a4bb">triangularApprox</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>)</td></tr>
<tr class="memdesc:a0c4f949174e97ccabdf916a2d1f8a4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that finds the minimum longest triangular path between a source vertex and a destination vertex.  <br /></td></tr>
<tr class="separator:a0c4f949174e97ccabdf916a2d1f8a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0b953b71c490d67eb63c6c2e6c2e27" id="r_a2d0b953b71c490d67eb63c6c2e6c2e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0b953b71c490d67eb63c6c2e6c2e27">findMinLongTriangularPath</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *dest)</td></tr>
<tr class="memdesc:a2d0b953b71c490d67eb63c6c2e6c2e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the minimum triangular path.  <br /></td></tr>
<tr class="separator:a2d0b953b71c490d67eb63c6c2e6c2e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8199a78b27e19897e2f26e638f56cd48" id="r_a8199a78b27e19897e2f26e638f56cd48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8199a78b27e19897e2f26e638f56cd48">findLongTriangularPath</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">longVertex</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *dest)</td></tr>
<tr class="memdesc:a8199a78b27e19897e2f26e638f56cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the longest triangular path.  <br /></td></tr>
<tr class="separator:a8199a78b27e19897e2f26e638f56cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61363e24e4d750a983f5766fa6aff0d" id="r_ae61363e24e4d750a983f5766fa6aff0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61363e24e4d750a983f5766fa6aff0d">christofidesAlgorithm</a> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:ae61363e24e4d750a983f5766fa6aff0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the Christofides algorithm.  <br /></td></tr>
<tr class="separator:ae61363e24e4d750a983f5766fa6aff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99c122871b80bad69e71469f5015d77" id="r_af99c122871b80bad69e71469f5015d77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af99c122871b80bad69e71469f5015d77">oddDegreeVertices</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; <a class="el" href="class_edge.html">mst</a>, <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; <a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:af99c122871b80bad69e71469f5015d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the vertices with odd degree.  <br /></td></tr>
<tr class="separator:af99c122871b80bad69e71469f5015d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa68b949ab0367beac7d263204fd8ea" id="r_aeaa68b949ab0367beac7d263204fd8ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaa68b949ab0367beac7d263204fd8ea">minimumWeightMatching</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; <a class="el" href="#af99c122871b80bad69e71469f5015d77">oddDegreeVertices</a>)</td></tr>
<tr class="memdesc:aeaa68b949ab0367beac7d263204fd8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the minimum weight matching.  <br /></td></tr>
<tr class="separator:aeaa68b949ab0367beac7d263204fd8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb6614e07a857bb5a7ff94917ce800" id="r_a64bb6614e07a857bb5a7ff94917ce800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64bb6614e07a857bb5a7ff94917ce800">createMultiGraph</a> (std::vector&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; edges, <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; <a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:a64bb6614e07a857bb5a7ff94917ce800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a multigraph.  <br /></td></tr>
<tr class="separator:a64bb6614e07a857bb5a7ff94917ce800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5c6de3abdf3534a739340007f4a3e" id="r_a96a5c6de3abdf3534a739340007f4a3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a5c6de3abdf3534a739340007f4a3e">eulerianCircuit</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">multigraph</a>)</td></tr>
<tr class="memdesc:a96a5c6de3abdf3534a739340007f4a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the Eulerian circuit.  <br /></td></tr>
<tr class="separator:a96a5c6de3abdf3534a739340007f4a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af0eda8473942ddaf7b70606200ec36" id="r_a2af0eda8473942ddaf7b70606200ec36"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af0eda8473942ddaf7b70606200ec36">hamiltonianCircuit</a> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="#a96a5c6de3abdf3534a739340007f4a3e">eulerianCircuit</a>, <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">multigraph</a>)</td></tr>
<tr class="memdesc:a2af0eda8473942ddaf7b70606200ec36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the Hamiltonian circuit.  <br /></td></tr>
<tr class="separator:a2af0eda8473942ddaf7b70606200ec36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd8832fae0d240a7ad2f59fc5fac46" id="r_a02fd8832fae0d240a7ad2f59fc5fac46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02fd8832fae0d240a7ad2f59fc5fac46">calculatePathCost</a> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path)</td></tr>
<tr class="memdesc:a02fd8832fae0d240a7ad2f59fc5fac46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the cost of the path.  <br /></td></tr>
<tr class="separator:a02fd8832fae0d240a7ad2f59fc5fac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c0f5532b5f75c43133bea628a5881f" id="r_ae6c0f5532b5f75c43133bea628a5881f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6c0f5532b5f75c43133bea628a5881f">twoOptImprovement</a> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path)</td></tr>
<tr class="memdesc:ae6c0f5532b5f75c43133bea628a5881f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to apply the 2-opt improvement to the path.  <br /></td></tr>
<tr class="separator:ae6c0f5532b5f75c43133bea628a5881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc10b1b7a589313115ca4a017cbbae" id="r_a23cc10b1b7a589313115ca4a017cbbae"><td class="memItemLeft" align="right" valign="top"><a id="a23cc10b1b7a589313115ca4a017cbbae" name="a23cc10b1b7a589313115ca4a017cbbae"></a>
<a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>threeOptImprovement</b> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path)</td></tr>
<tr class="separator:a23cc10b1b7a589313115ca4a017cbbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec3f11c030e96d850d7cbec39fc342" id="r_ab5ec3f11c030e96d850d7cbec39fc342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5ec3f11c030e96d850d7cbec39fc342">edgeCost</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, <a class="el" href="class_edge.html">int</a> dest)</td></tr>
<tr class="memdesc:ab5ec3f11c030e96d850d7cbec39fc342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the cost of the path.  <br /></td></tr>
<tr class="separator:ab5ec3f11c030e96d850d7cbec39fc342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c097768b554ff05b7758ac1b42fe3c0" id="r_a8c097768b554ff05b7758ac1b42fe3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c097768b554ff05b7758ac1b42fe3c0">isConnected</a> ()</td></tr>
<tr class="memdesc:a8c097768b554ff05b7758ac1b42fe3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if the graph is connected.  <br /></td></tr>
<tr class="separator:a8c097768b554ff05b7758ac1b42fe3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4d436494112913b3080bfbe3eef25a" id="r_a8e4d436494112913b3080bfbe3eef25a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4d436494112913b3080bfbe3eef25a">realTriangularApproximationHeuristic</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:a8e4d436494112913b3080bfbe3eef25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calculates the shortest path using triangular approximation heuristic, if the graph is connected.  <br /></td></tr>
<tr class="separator:a8e4d436494112913b3080bfbe3eef25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad104411c646aa46be01886bfa96a9b8" id="r_aad104411c646aa46be01886bfa96a9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad104411c646aa46be01886bfa96a9b8">triangularApproximationHeuristicReal</a> (<a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">src</a>, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;<a class="el" href="class_edge.html">time</a>)</td></tr>
<tr class="memdesc:aad104411c646aa46be01886bfa96a9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the shortest path in a graph using the triangular approximation heuristic, given a source vertex.  <br /></td></tr>
<tr class="separator:aad104411c646aa46be01886bfa96a9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537f67a94a2db9b79fffc5f3607bb8f3" id="r_a537f67a94a2db9b79fffc5f3607bb8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a537f67a94a2db9b79fffc5f3607bb8f3">checkerPath</a> (std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;path, std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">notVisited</a>)</td></tr>
<tr class="memdesc:a537f67a94a2db9b79fffc5f3607bb8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if all vertices in the graph have been visited by the given path.  <br /></td></tr>
<tr class="separator:a537f67a94a2db9b79fffc5f3607bb8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb92bb61a3d82755779398185c96acd" id="r_aafb92bb61a3d82755779398185c96acd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb92bb61a3d82755779398185c96acd">hasVisitedAllVertices</a> ()</td></tr>
<tr class="memdesc:aafb92bb61a3d82755779398185c96acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if all vertices in the graph have been visited by the given path.  <br /></td></tr>
<tr class="separator:aafb92bb61a3d82755779398185c96acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a842866bab3ab3e56b5fda1bbeaafb106" id="r_a842866bab3ab3e56b5fda1bbeaafb106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">static</a> std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842866bab3ab3e56b5fda1bbeaafb106">getVertexSetOfVertex</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">source</a>)</td></tr>
<tr class="memdesc:a842866bab3ab3e56b5fda1bbeaafb106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the vertex set of a vertex.  <br /></td></tr>
<tr class="separator:a842866bab3ab3e56b5fda1bbeaafb106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a780e8e40d69dbc8a0291ea76a634890b" id="r_a780e8e40d69dbc8a0291ea76a634890b"><td class="memItemLeft" align="right" valign="top"><a id="a780e8e40d69dbc8a0291ea76a634890b" name="a780e8e40d69dbc8a0291ea76a634890b"></a>
<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>graph</b></td></tr>
<tr class="separator:a780e8e40d69dbc8a0291ea76a634890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9607d0f0ba207963f2204fb6e355ba34" id="r_a9607d0f0ba207963f2204fb6e355ba34"><td class="memItemLeft" align="right" valign="top"><a id="a9607d0f0ba207963f2204fb6e355ba34" name="a9607d0f0ba207963f2204fb6e355ba34"></a>
std::map&lt; <a class="el" href="class_edge.html">int</a>, std::pair&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_map_coordinates</b></td></tr>
<tr class="separator:a9607d0f0ba207963f2204fb6e355ba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab738324b6b76cfc54997a4f7b87d49c3" name="ab738324b6b76cfc54997a4f7b87d49c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab738324b6b76cfc54997a4f7b87d49c3">&#9670;&#160;</a></span>addAllEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::addAllEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>choice</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add all edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">choice</td><td>The file. </td></tr>
    <tr><td class="paramname">type</td><td>Small or Extra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5b68ee88c4d1f30f96f41688dd77594" name="ae5b68ee88c4d1f30f96f41688dd77594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b68ee88c4d1f30f96f41688dd77594">&#9670;&#160;</a></span>auxBacktrackingAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::auxBacktrackingAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v_src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vertex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>current_path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>cost_now</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that explores all possible paths from the source vertex to all other vertices in the graph. </p>
<p>This function uses backtracking to avoid unnecessary computation.</p>
<p>Complexity: O(N!) where N is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_src</td><td></td></tr>
    <tr><td class="paramname">vertex</td><td></td></tr>
    <tr><td class="paramname">current_path</td><td></td></tr>
    <tr><td class="paramname">res</td><td></td></tr>
    <tr><td class="paramname">cost_now</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4e1d3587c5193995fdb9f782c8e5b1b" name="ac4e1d3587c5193995fdb9f782c8e5b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e1d3587c5193995fdb9f782c8e5b1b">&#9670;&#160;</a></span>backtrackingAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::backtrackingAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that explores all possible paths from the source vertex to all other vertices in the graph. </p>
<p>This function calls the auxiliary function auxBacktrackingAlgorithm.</p>
<p>Complexity: O(N!) where N is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">time</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="a842ea96623f69e3519731989f2568e5f" name="a842ea96623f69e3519731989f2568e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842ea96623f69e3519731989f2568e5f">&#9670;&#160;</a></span>calculateDistanceHaverside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::calculateDistanceHaverside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lat1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>long1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lat2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>long2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the distance between two points using the Haverside formula. </p>
<p>Complexity: O(1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>The latitude of point 1. </td></tr>
    <tr><td class="paramname">long1</td><td>The longitude of point 1. </td></tr>
    <tr><td class="paramname">lat2</td><td>The latitude of point 2. </td></tr>
    <tr><td class="paramname">long2</td><td>The longitude of point 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two points. </dd></dl>

</div>
</div>
<a id="a02fd8832fae0d240a7ad2f59fc5fac46" name="a02fd8832fae0d240a7ad2f59fc5fac46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd8832fae0d240a7ad2f59fc5fac46">&#9670;&#160;</a></span>calculatePathCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::calculatePathCost </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the cost of the path. </p>
<p>Complexity: O(V^2) where V is the number of vertices in the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="a54873ab1bfc738303fa75a8b820e3e32" name="a54873ab1bfc738303fa75a8b820e3e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54873ab1bfc738303fa75a8b820e3e32">&#9670;&#160;</a></span>checkEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> grafos::checkEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if an edge exists between two vertices. </p>
<p>If it exists, the function stores the edge Edge&lt;int&gt;* &amp;edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination vertex. </td></tr>
    <tr><td class="paramname">g</td><td>The graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge exists, false otherwise. </dd></dl>

</div>
</div>
<a id="a6d8cee0b704f0caa51afbea8d85c2562" name="a6d8cee0b704f0caa51afbea8d85c2562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8cee0b704f0caa51afbea8d85c2562">&#9670;&#160;</a></span>checkEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> grafos::checkEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vertex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&amp;</td>          <td class="paramname"><span class="paramname"><em>edge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if an edge exists between two vertices. </p>
<p>Complexity: O(E) where E is the number of edges that exist in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
    <tr><td class="paramname">edge</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge exists, false otherwise. </dd></dl>

</div>
</div>
<a id="a537f67a94a2db9b79fffc5f3607bb8f3" name="a537f67a94a2db9b79fffc5f3607bb8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537f67a94a2db9b79fffc5f3607bb8f3">&#9670;&#160;</a></span>checkerPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> grafos::checkerPath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>notVisited</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if all vertices in the graph have been visited by the given path. </p>
<p>Complexity: O(V) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">notVisited</td><td>The not visited vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all vertices have been visited, false otherwise. </dd></dl>

</div>
</div>
<a id="aecbba3bc3edbc813f3959cf473791859" name="aecbba3bc3edbc813f3959cf473791859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbba3bc3edbc813f3959cf473791859">&#9670;&#160;</a></span>checkGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::checkGraph </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check the graph. </p>
<p>Complexity: O(V * E^4) if the graph is "small", where V is the number of vertices of the graph and E is the number of edges that exist in each vertex, O(V^3) if "extra" where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61363e24e4d750a983f5766fa6aff0d" name="ae61363e24e4d750a983f5766fa6aff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61363e24e4d750a983f5766fa6aff0d">&#9670;&#160;</a></span>christofidesAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::christofidesAlgorithm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the Christofides algorithm. </p>
<p>This function calls the auxiliary functions oddDegreeVertices, minimumWeightMatching, createMultiGraph, eulerianCircuit, and hamiltonianCircuit.</p>
<p>Complexity: O(V^3) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">time</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="a70ffefbe60aabccb9bb4ca1665f7159a" name="a70ffefbe60aabccb9bb4ca1665f7159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ffefbe60aabccb9bb4ca1665f7159a">&#9670;&#160;</a></span>commanderTriangularApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::commanderTriangularApprox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that applies the triangular approximation to all vertices in the graph. </p>
<p>Complexity: O(V^2) where V is the number of vertices in the graph. </p>

</div>
</div>
<a id="aa44f7d8b936ce9f90f582f23fe8feeb2" name="aa44f7d8b936ce9f90f582f23fe8feeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44f7d8b936ce9f90f582f23fe8feeb2">&#9670;&#160;</a></span>convertPrimToGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; grafos::convertPrimToGraph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;</td>          <td class="paramname"><span class="paramname"><em>mst</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert the minimum spanning tree into a graph. </p>
<p>Complexity: O(V + E), where V is the number of vertices in the minimum spanning tree (MST) and E is the number of edges in the MST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a41e661e5c0a2290e12c2abac63c8dd16" name="a41e661e5c0a2290e12c2abac63c8dd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e661e5c0a2290e12c2abac63c8dd16">&#9670;&#160;</a></span>convertToRadians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::convertToRadians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>degree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert from degrees to radians. </p>
<p>Complexity: O(1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>The degree to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree in radians. </dd></dl>

</div>
</div>
<a id="a254d3ec5988d33c1598742557c7b9600" name="a254d3ec5988d33c1598742557c7b9600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254d3ec5988d33c1598742557c7b9600">&#9670;&#160;</a></span>copyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; grafos::copyGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to copy a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copied graph. </dd></dl>

</div>
</div>
<a id="a64bb6614e07a857bb5a7ff94917ce800" name="a64bb6614e07a857bb5a7ff94917ce800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bb6614e07a857bb5a7ff94917ce800">&#9670;&#160;</a></span>createMultiGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; grafos::createMultiGraph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;</td>          <td class="paramname"><span class="paramname"><em>edges</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to create a multigraph. </p>
<p>Complexity: O(E^2) where E is the number of edges in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td></td></tr>
    <tr><td class="paramname">g</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multigraph. </dd></dl>

</div>
</div>
<a id="ab5ec3f11c030e96d850d7cbec39fc342" name="ab5ec3f11c030e96d850d7cbec39fc342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ec3f11c030e96d850d7cbec39fc342">&#9670;&#160;</a></span>edgeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::edgeCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the cost of the path. </p>
<p>Complexity: O(V) where V is the number of vertices in the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="a96a5c6de3abdf3534a739340007f4a3e" name="a96a5c6de3abdf3534a739340007f4a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a5c6de3abdf3534a739340007f4a3e">&#9670;&#160;</a></span>eulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; grafos::eulerianCircuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>multigraph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the Eulerian circuit. </p>
<p>Complexity: O(E) where E is the number of edges in the multigraph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multigraph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Eulerian circuit. </dd></dl>

</div>
</div>
<a id="a8199a78b27e19897e2f26e638f56cd48" name="a8199a78b27e19897e2f26e638f56cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8199a78b27e19897e2f26e638f56cd48">&#9670;&#160;</a></span>findLongTriangularPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::findLongTriangularPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>longVertex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the longest triangular path. </p>
<p>Complexity: O(n) where n is the number of adjacent vertices of the source vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">longVertex</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the longest triangular path. </dd></dl>

</div>
</div>
<a id="a2d0b953b71c490d67eb63c6c2e6c2e27" name="a2d0b953b71c490d67eb63c6c2e6c2e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0b953b71c490d67eb63c6c2e6c2e27">&#9670;&#160;</a></span>findMinLongTriangularPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::findMinLongTriangularPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the minimum triangular path. </p>
<p>Complexity: O(n^2) where n is the number of adjacent vertices of the source vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the minimum longest triangular path. </dd></dl>

</div>
</div>
<a id="a842866bab3ab3e56b5fda1bbeaafb106" name="a842866bab3ab3e56b5fda1bbeaafb106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842866bab3ab3e56b5fda1bbeaafb106">&#9670;&#160;</a></span>getVertexSetOfVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; grafos::getVertexSetOfVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the vertex set of a vertex. </p>
<p>Complexity: O(n) where n is the number of edges that exist in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex set of the vertex. </dd></dl>

</div>
</div>
<a id="a2af0eda8473942ddaf7b70606200ec36" name="a2af0eda8473942ddaf7b70606200ec36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af0eda8473942ddaf7b70606200ec36">&#9670;&#160;</a></span>hamiltonianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; grafos::hamiltonianCircuit </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>eulerianCircuit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>multigraph</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the Hamiltonian circuit. </p>
<p>Complexity: O(V) where V is the number of vertices in the eulerian circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eulerianCircuit</td><td></td></tr>
    <tr><td class="paramname">multigraph</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hamiltonian circuit. </dd></dl>

</div>
</div>
<a id="aafb92bb61a3d82755779398185c96acd" name="aafb92bb61a3d82755779398185c96acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb92bb61a3d82755779398185c96acd">&#9670;&#160;</a></span>hasVisitedAllVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> grafos::hasVisitedAllVertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if all vertices in the graph have been visited by the given path. </p>
<p>Complexity: O(V) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">notVisited</td><td>The not visited vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all vertices have been visited, false otherwise. </dd></dl>

</div>
</div>
<a id="a8c097768b554ff05b7758ac1b42fe3c0" name="a8c097768b554ff05b7758ac1b42fe3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c097768b554ff05b7758ac1b42fe3c0">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">bool</a> grafos::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if the graph is connected. </p>
<p>Complexity: O(V + E) where V is the number of vertices in the graph and E is the number of edges in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the graph is connected, false otherwise. </dd></dl>

</div>
</div>
<a id="af1626d9c196b32de2fd96bde5addedaf" name="af1626d9c196b32de2fd96bde5addedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1626d9c196b32de2fd96bde5addedaf">&#9670;&#160;</a></span>lowerBoundCommander()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::lowerBoundCommander </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>flag</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the value of the lower bound. </p>
<p>This function calls all the auxiliary functions to calculate the lower bound.</p>
<p>Complexity: O(E * log V) if flag is false, where E is the number of edges that exist in each vertex and V is the number of vertices in the graph. If flag is true, O(V * (E + V * log V)), where V is the number of vertices in the graph and E is the number of edges in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td></td></tr>
    <tr><td class="paramname">time</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the lower bound. </dd></dl>

</div>
</div>
<a id="ad6590210b146b0659f6779c6db071d74" name="ad6590210b146b0659f6779c6db071d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6590210b146b0659f6779c6db071d74">&#9670;&#160;</a></span>maxWeightOneTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::maxWeightOneTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>primCost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the maximum weight of a tree. </p>
<p>Complexity: O(E) where E is the number of edges that exist in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">primCost</td><td>The cost of the prim algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum weight of the tree. </dd></dl>

</div>
</div>
<a id="aeaa68b949ab0367beac7d263204fd8ea" name="aeaa68b949ab0367beac7d263204fd8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa68b949ab0367beac7d263204fd8ea">&#9670;&#160;</a></span>minimumWeightMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; grafos::minimumWeightMatching </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;</td>          <td class="paramname"><span class="paramname"><em>oddDegreeVertices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the minimum weight matching. </p>
<p>Complexity: O(V^3) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oddDegreeVertices</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum weight matching. </dd></dl>

</div>
</div>
<a id="ae00171c8a1453c1ee4bbb7a5c7444bba" name="ae00171c8a1453c1ee4bbb7a5c7444bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00171c8a1453c1ee4bbb7a5c7444bba">&#9670;&#160;</a></span>normalizationRealCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::normalizationRealCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to normalize the real coordinates of the graph. </p>
<p>Complexity: O(n^2) where n is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1e56ee09b55cfa54f9d781ab6eb6fbf" name="ad1e56ee09b55cfa54f9d781ab6eb6fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e56ee09b55cfa54f9d781ab6eb6fbf">&#9670;&#160;</a></span>normalizeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::normalizeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to normalize the graph. </p>
<p>Complexity: O(n^4) where n is the number of edges that exist in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af99c122871b80bad69e71469f5015d77" name="af99c122871b80bad69e71469f5015d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99c122871b80bad69e71469f5015d77">&#9670;&#160;</a></span>oddDegreeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; grafos::oddDegreeVertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;</td>          <td class="paramname"><span class="paramname"><em>mst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find the vertices with odd degree. </p>
<p>Complexity: O(V) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td></td></tr>
    <tr><td class="paramname">g</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertices with odd degree. </dd></dl>

</div>
</div>
<a id="a6b6e14b39e16bce4ccce94e88a2b17e6" name="a6b6e14b39e16bce4ccce94e88a2b17e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e14b39e16bce4ccce94e88a2b17e6">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; grafos::prim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the prim's algorithm. </p>
<p>Complexity: O(E * logV), where E is the number of edges that exist in each vertex and V is the number of vertices in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>The minimum spanning tree. </dd></dl>

</div>
</div>
<a id="af10cde47adf8493b4cada671f10397b9" name="af10cde47adf8493b4cada671f10397b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10cde47adf8493b4cada671f10397b9">&#9670;&#160;</a></span>primTotalCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::primTotalCost </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the total cost of the minimum spanning tree. </p>
<p>Complexity: O(V * E), where V is the number of vertices in the minimum spanning tree (MST) and E is the number of edges in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total cost of the minimum spanning tree. </dd></dl>

</div>
</div>
<a id="a97bbb41ce774505a8a69d46ae95f7df5" name="a97bbb41ce774505a8a69d46ae95f7df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bbb41ce774505a8a69d46ae95f7df5">&#9670;&#160;</a></span>readCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::readCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>choice</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read the coordinates of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">choice</td><td>The file. </td></tr>
    <tr><td class="paramname">type</td><td>Small or Extra.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coordinates of the vertex. </dd></dl>

</div>
</div>
<a id="a6839bcdcc61158c81bd19fcabc3d8867" name="a6839bcdcc61158c81bd19fcabc3d8867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6839bcdcc61158c81bd19fcabc3d8867">&#9670;&#160;</a></span>readGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::readGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>choice</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read the graph. </p>
<p>There are three types of graphs: Small, Extra and Real.</p>
<p>Type - Small 1 - shipping.csv, 2 - stadiums.csv, 3 - tourism.csv, 4 - test44.csv</p>
<p>Type - Extra 1 - 25, 2 - 50, 3 - 75, 4 - 100, 5 - 200, 6 - 300, 7 - 400, 8 - 500, 9 - 600, 10 - 700, 11 - 800, 12 - 900</p>
<p>Type - Real 1- Graph1, 2- Graph2, 3- Graph3</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">choice</td><td>The file. </td></tr>
    <tr><td class="paramname">type</td><td>Small or Extra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e4d436494112913b3080bfbe3eef25a" name="a8e4d436494112913b3080bfbe3eef25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4d436494112913b3080bfbe3eef25a">&#9670;&#160;</a></span>realTriangularApproximationHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::realTriangularApproximationHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that calculates the shortest path using triangular approximation heuristic, if the graph is connected. </p>
<p>Complexity: O(E) where E is the number of edges in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">time</td><td>The time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path (-1 if the graph is not connected). </dd></dl>

</div>
</div>
<a id="aac3b0761f909a8cbdff939f6d0de17df" name="aac3b0761f909a8cbdff939f6d0de17df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3b0761f909a8cbdff939f6d0de17df">&#9670;&#160;</a></span>resetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::resetStatus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to reset the status of the graph. </p>
<p>This function resets the status of the graph by setting the visited attribute of all vertices to false. </p>

</div>
</div>
<a id="a838a6993836d0ebb80076ed840c55ada" name="a838a6993836d0ebb80076ed840c55ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838a6993836d0ebb80076ed840c55ada">&#9670;&#160;</a></span>triangular_approximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::triangular_approximation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v3</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that makes the triangular approximation of the graph. </p>
<p>Complexity: O(n) where n is the number of edges that exist in each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vertex. </td></tr>
    <tr><td class="paramname">v3</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c4f949174e97ccabdf916a2d1f8a4bb" name="a0c4f949174e97ccabdf916a2d1f8a4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4f949174e97ccabdf916a2d1f8a4bb">&#9670;&#160;</a></span>triangularApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::triangularApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that finds the minimum longest triangular path between a source vertex and a destination vertex. </p>
<p>Complexity: O(n^2), where n is the number of adjacent vertices to the source vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2005eb1d02071cdb216fdf0b55721d" name="a4a2005eb1d02071cdb216fdf0b55721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2005eb1d02071cdb216fdf0b55721d">&#9670;&#160;</a></span>triangularApproximationHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::triangularApproximationHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the triangular approximation heuristic. </p>
<p>This function calls the auxiliary function triangularApproximationHeuristic.</p>
<p>Complexity: O(V^2) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">time</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="aad104411c646aa46be01886bfa96a9b8" name="aad104411c646aa46be01886bfa96a9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad104411c646aa46be01886bfa96a9b8">&#9670;&#160;</a></span>triangularApproximationHeuristicReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> grafos::triangularApproximationHeuristicReal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; <a class="el" href="class_edge.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the shortest path in a graph using the triangular approximation heuristic, given a source vertex. </p>
<p>Complexity: O(V^2) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">time</td><td>The time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<a id="ae6c0f5532b5f75c43133bea628a5881f" name="ae6c0f5532b5f75c43133bea628a5881f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c0f5532b5f75c43133bea628a5881f">&#9670;&#160;</a></span>twoOptImprovement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> grafos::twoOptImprovement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to apply the 2-opt improvement to the path. </p>
<p>Complexity: O(V^2) where V is the number of vertices in the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/User/Desktop/FEUP/2023_24/DA/project_2_final/ProjetoDA2/src/structs/data_type/<a class="el" href="grafos_8h_source.html">grafos.h</a></li>
<li>C:/Users/User/Desktop/FEUP/2023_24/DA/project_2_final/ProjetoDA2/src/structs/data_type/<b>grafos.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
